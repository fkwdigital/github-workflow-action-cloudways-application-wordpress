{"version":3,"file":"index.js","mappings":";;;;;;;AAAA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["../external node-commonjs \"os\"","../webpack/bootstrap","../webpack/runtime/compat",".././src/index.js"],"sourcesContent":["module.exports = require(\"os\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","// Compute destination\nfunction computeDest() {\n  if (cfg.target) return cfg.target; // explicit wins\n  if (!cfg.targetBase) return `/home/${cfg.user}/`; // sensible fallback\n  const appended = cfg.folderName\n    ? path.posix.join(cfg.targetBase, cfg.folderName)\n    : cfg.targetBase;\n  return appended.endsWith('/') ? appended : `${appended}/`;\n}\n\nconst remoteDest = `${cfg.user}@${cfg.host}:${computeDest()}`;\n\n// Build exclude list\nconst extra = cfg.extraExclude\n  ? cfg.extraExclude\n      .split(',')\n      .map((s) => s.trim())\n      .filter(Boolean)\n  : [];\nconst EXCLUDES = [...ALWAYS_EXCLUDE, ...extra];\n\n// Ensure trailing slash for \"copy contents\" when using public/\nfunction withTrailingSlash(p) {\n  return p && !p.endsWith('/') ? `${p}/` : p;\n}\n\nconst localSrc = path.posix.join(GITHUB_WORKSPACE, withTrailingSlash(cfg.source || ''));\n\nconsole.log(`[general] GITHUB_WORKSPACE: ${GITHUB_WORKSPACE}`);\nconsole.log(`[deploy] Local source → ${localSrc}`);\nconsole.log(`[deploy] Remote dest → ${remoteDest}`);\nconsole.log(`[deploy] Rsync args → ${cfg.rsyncArgs}`);\nconsole.log(`[deploy] Always-excluding (${EXCLUDES.length}) patterns.`);\n\nfunction runRsync(privateKeyPath) {\n  validateRsync(() => {\n    try {\n      nodeRsync(\n        {\n          src: localSrc,\n          dest: remoteDest,\n          args: cfg.rsyncArgs.split(' ').filter(Boolean),\n          privateKey: privateKeyPath,\n          port: cfg.port,\n          excludeFirst: EXCLUDES,\n          ssh: true,\n          sshCmdArgs: ['-o StrictHostKeyChecking=no'],\n          recursive: true,\n        },\n        (error, stdout, stderr, cmd) => {\n          if (error) {\n            console.error('⚠️ [Rsync] error: ', error.message);\n            console.log('⚠️ [Rsync] stderr: ', stderr);\n            console.log('⚠️ [Rsync] stdout: ', stdout);\n            console.log('⚠️ [Rsync] cmd: ', cmd);\n            process.abort();\n          } else {\n            console.log('✅ [Rsync] finished.', stdout);\n          }\n        }\n      );\n    } catch (err) {\n      console.error('⚠️ [Rsync] command error: ', err.message, err.stack);\n      process.abort();\n    }\n  });\n}\n\n(function main() {\n  // Prepare temp key\n  const privateKeyPath = addSshKey(cfg.key, cfg.keyName);\n  // Make sure ~/.ssh/known_hosts exists (idempotent)\n  const osHome = process.env.HOME || require('os').homedir();\n  validateDir(path.join(osHome, '.ssh'));\n  validateFile(path.join(osHome, '.ssh', 'known_hosts'));\n  // Rsync\n  runRsync(privateKeyPath);\n})();\n"],"names":[],"sourceRoot":""}